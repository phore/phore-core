<?php

/**
 * phore_glob - Enhanced glob utility supporting * (single-level) and ** (multi-level).
 * 
 * This version includes:
 *  - An optional $rootPath parameter to restrict returned paths.
 *  - An optional $exclude parameter, which can:
 *    - Be an array of patterns to exclude.
 *    - Be a boolean (true to throw exceptions for security violations, false to silently skip).
 *  - An $absolute parameter to return absolute paths.
 */
class PhoreGlob
{
    public static function search(string|array $pattern, string|array|null $exclude = null): array
    {
        $patternArr = (array)$pattern;
        $excludeArr = (array)$exclude;
        $results = [];

        foreach ($patternArr as $pat) {
                     

            $rootDir = explode ('*', $pat, 2)[0];
            $rootDir = dirname($rootDir);
            
            $searchPattern = $pat;
            
            $iterator = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($rootDir ?: '.',
                    FilesystemIterator::SKIP_DOTS | FilesystemIterator::FOLLOW_SYMLINKS)
            );

            foreach ($iterator as $file) {
                if (!$file->isFile()) {
                    continue;
                }
                $filePath = $rootDir
                    ? $rootDir . '/' . $iterator->getSubPathName()
                    : $iterator->getSubPathName();
                $filePath = str_replace('\\', '/', $filePath);

                if (self::matchPattern($filePath, $searchPattern) && !self::isExcluded($filePath, $excludeArr)) {
                    $results[] = $filePath;
                }
            }
        }
        
        return array_values(array_unique($results));
    }

    private static function matchPattern(string $filePath, string $pattern): bool
    {
        $regex = str_replace(['.', '**'], ['\.', '.+'], $pattern);
        $regex = str_replace('*', '[^/]*', $regex);
        return (bool)preg_match('#^' . $regex . '$#i', $filePath);
    }

    private static function isExcluded(string $filePath, array $excludes): bool
    {
        foreach ($excludes as $ex) {
            $regex = str_replace(['.', '**'], ['\.', '.+'], $ex);
            $regex = str_replace('*', '[^/]*', $regex);
            if (preg_match('#^' . $regex . '$#i', $filePath)) {
                return true;
            }
        }
        return false;
    }
}

/**
 * phore_glob - Enhanced glob utility supporting * (single-level) and ** (multi-level).
 * 
 * Examples
 * - phore_glob("*.txt") - Returns all .txt files in the current directory.
 * - phore_glob("*.(txt|md)") - Returns all .txt and .md files in the current directory.
 * 
 * @param string|array $pattern
 * @param string|array|null $exclude
 * @return array
 */
function phore_glob(string|array $pattern, string|array|null $exclude = null): array
{
    return PhoreGlob::search($pattern, $exclude);
}
/**
 * Checks if a given path is within the specified root path, including being equal to root.
 */
function phore_isPathWithinRoot(string $path, string $root): bool
{
    $path = realpath($path);
    $root = realpath($root);

    if ($path === false || $root === false) {
        return false;
    }

    if (strpos($path, $root) !== 0) {
        return false;
    }

    // Ensure any extra characters after root form a valid subpath
    return strlen($path) === strlen($root) || $path[strlen($root)] === DIRECTORY_SEPARATOR;
}